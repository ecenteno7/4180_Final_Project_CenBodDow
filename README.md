# RPi3 IoT Alarm Clock
### ECE 4180 A
Brett Bodamer, Erik Centeno, Dallas Downing

## Overview
The goal of this project is to merge components from two major products in order to design a more practical, consumer-oriented experience. Many Internet of Things devices can tend to be somewhat gimmicky, as all new technologies are, in order to show off the newest features that can be exploited to create the next revolution. From internet connected kitchen devices, to more practical devices such as an Amazon Echo, to industrial applications which are fueling the growth of the manufacturing industry, these IoT devices have a lot of potential to start to merge into holistic products with a lot of practical value.

![Final Product](URL)

With the advent of smartphones, smart assistants, and smart watches, the alarm clock has seemingly faded into the technology graveyard. However, our group believed that alarm clocks still have the potential to make a resurgence built around practical features. What if your alarm clock acted like your mom when you were younger, forcing you to get out of bed and not leaving you alone until you were **_really_** awake? This smart alarm clock allows you to set an alarm along with a code the night before. The next morning, you have to remember the code that you entered the night before in order to turn the alarm off. Otherwise, the clock will increase the stimulus by turning up the volume and increasing the LED blinking intensity. This keeps the user on his/her toes and is built around the core functionality of actually making sure they start their day right. Additionally, the clock is paired with a high resolution touchscreen display that shows at-a-glance current weather and world news. The alarm consists of an LED ring stimulus and music, which are detailed later on this page.

## Components
### AWS IoT Core
Being an Internet of Things device, Amazon Web Services IoT Core is the backbone of how this alarm clock runs. IoT Core runs off of using MQTT as a communication protocol between devices. This project uses three “devices” which are communicating with one another: a JavaScript controlled GUI which displays to the user, a C script which controls the speakers and LED ring, and the user’s cell phone which is used to set the alarms.

### MQTT
MQTT is a lightweight communication protocol which is commonly used in IoT devices. It is based off of the premise that many devices exist and do not communicate directly with one another. Instead, all communication is routed through a “broker.” Devices can subscribe to various “topics” which are used to differentiate what information they see/can send information to. Likewise, the devices can publish to various topics. Any device that is subscribed to a topic which has a message published to it will be able to see these messages. The broker in this case manages what devices are subscribed to which topics. When a device publishes a message to a specific topic, the broker handles this message and sends it to all other devices subscribed to the same topic. This protocol is fantastic for vast, complicated sensor networks with various functionalities and workgroups.

### Our Device Topology
In our case, the layout is much simpler. The JavaScript GUI is served in an HTML file from a Node.JS server. This Node.JS server is built inside of a script which connects to AWS IoT Core. The script subscribes to the “sdkTest/sub” topic and also publishes to the same topic. This script is detailed later in this document. The C Script which controls the speakers and LED ring also is written inside of a larger script which connects to AWS IoT Core (and subscribes/publishes to “sdkTest/sub”). Lastly, the user’s cell phone connects to the system by using a node-red built user interface. More information on node-red setup can be found here (add hyperlink, don’t need to go into more detail since it’s covered in lab). The UI is built using nodes that are installed from node-red-dashboard. This webpage takes in information inputted by the user to set their alarm, including the date/time and code to turn it off. A JavaScript function converts this user input into a single string which can be interpreted by the C Script and GUI and sends it to the AWS IoT Core broker on the topic “sdkTest/sub.” This lays the foundation for communication between the three major functions in our embedded device.

### Included Files
Information and a detailed tutorial for AWS IoT Core setup can be found [here](https://aws.amazon.com/iot-core/). The GitHub repository in this project omits the entirety of the AWS provided directories, as to avoid publishing any private information to a public location. AWS requires a full account setup and includes various API keys and certificates inside of its directories, so only the main scripts that were edited are included in this repository (with sensitive information excluded). The files “device-example.js” and “subscribe-publish-sample.c” are included to show how the embedded device is setup and runs. If you would like to recreate this project, simply replace these files in the AWS provided sample project directories and include your own user-generated certificates and keys from your account.

### Raspberry Pi Foundation Touch Screen
The alarm clock is outfitted with a touch display which can be found [here](https://www.raspberrypi.org/products/raspberry-pi-touch-display/). This connects to the Raspberry Pi using a short ribbon cable in the Pi’s DSI Port. The display receives power from the Pi’s 5V Out and Ground GPIO connectors. The display is 800x480, but the Pi automatically adjusts its resolution and output for this.

### JavaScript Controlled GUI
The JavaScript GUI is one of the two fronts that the user interacts with. Mostly, this component exists to show the user at-a-glance information that other IoT devices may display, such as current time, weather, and a scrolling daily news feed. Additionally, this is what the user interacts with to turn the alarm off in the morning. 

![GUI](URL)

The JavaScript code is found in device-example.js, which connects to AWS IoT core and establishes a subscription on topic “sdkTest/sub” using our credentials. Also in this script, an Express (NodeJS module) server is set up which serves the browser an HTML page, index.html. The Express server also serves the client-side JavaScript in the HTML images from the /img directory.

When the script receives a message, it runs a function which you can see in the device.on(‘message’, function) listener. This function checks to see if the received message is in the format 1_A_CODE or 1_B_CODE. The “1” signifies that this is a message intended to turn the number pad script on or off. The “A” tells the script to emit a message to the client-side JavaScript to turn the number pad display code on, and the “B” tells it to turn the code off. The Node.JS server and the client-side JavaScript communicate using the Socket.IO library and module, which has detailed information found [here](https://socket.io/docs/). The client-side JavaScript has an event listener waiting for the “enableNumPad.alarmCode” or “disableNumPad” message from the Node.JS server, which has a function to run for either message. The first message turns on the display for the number pad and listens for the entry by the user. If the entry matches the code that was sent along with the “enableNumPad” message, the client-side Javascript sends an “alarmNotification” message with a payload of “true” to the Node.JS server. For each incorrect code entry attempt, the client-side script sends “alarmNotification” message with a payload of “false.” The Node.JS server has an event listener that waits for these alarmNotification messages, and runs a function for either message that is received. The function either publishes a “3_0” or a “3_1” to the topic “sdkTest/sub” which the IoT Core MQTT broker receives and sends off to the C script.

While all of this JavaScript runs while the alarm is going off, the rest of the client-side JavaScript serves to dynamically update the HTML GUI that the user is seeing. The weather is displayed using the OpenWeatherMap API (details can be found [here](https://openweathermap.org/current)) by using an httpGet() request. The current news is displayed using an RSS feed from BBC World News. The client-side JavaScript listens for the Node.JS server to update the newest entries from the RSS feed using the parser.parseURL() function and loops through displaying them every 10 seconds. After 10 stories have been displayed, the client-side JavaScript emits a feedUpdateREQ message which tells the Node.JS server to pull the RSS feed again for refreshed news. Additionally, the current time is displayed using the startTime() and checkTime() functions in the client-side JavaScript in index.html. The page is styled using CSS and is updated with the JavaScript by editing the innerHTML or stye.display of each element.

The GUI can be launched by visiting localhost:3000 in the DuckDuckGo browser on the Raspberry Pi after the following startup command is run. To run this properly, the following command can be run in a bash terminal on the Raspberry Pi in the same directory as “device-example.js”:

`node device-example.js --host-name=HOSTNAME --private-key=PRIVKEY.private.key --client-certificate=CLIENTCERT.cert.pem --ca-certificate=root-CA.crt --client-id=NodeJS --test-mode=1`

These files should have paths leading to them, if they are not in the same directory as the device-example.js file. The following logic diagram shows an example of communication when a user sets an alarm from the node-red UI from their phone. More detail is given later on how to properly execute our clock’s demo.

![Alarm Set Logic](URL)

As shown, the JavaScript code will trigger the number pad to turn on when a message is published to the topic “sdkTest/sub” indicating that the alarm is now on. The logic diagrams for when the alarm stimuli need to be increased/turned off are found in the next section.
